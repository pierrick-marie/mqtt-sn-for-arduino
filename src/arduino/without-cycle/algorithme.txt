// Modele Arduino sans cycle

// Definition des constantes
TOPIC_NAME
MODULE_NAME
DISCONNECT_NOW 
ACCEPTED 
REJECTED 
KEEP_ALIVE
FLAG 
RADIUS

// Definition des variables
msg = ""
topicId = -1

// Methode appele au lancement de lâ€™Arduino uniquement 
setup () {
	searchgw(RADIUS)
}

// Methode appele en bsoucle
loop() {
	// Nouvel evenement Arduino detecte 
	if ( eventCaptured ){
		if ( !connected() ){
			connect( FLAG, KEEP_ALIVE, MODULE_NAME )
		}
	}
}

getMessage () {
	return eventCaptured.getValue();
}

// Callback de la methode connect 
MQTTSN_connack_handler( msg_connack ) {
	if ( msg_connack->return_code == ACCEPTED && topic_id != -1 ){
	 	pingreq( MODULE_NAME )
	} else { 
		register( TOPIC_NAME )
	}
}

// Callback de la methode pingreq
MQTTSN_pingresp_handler() {
	msg = getMessage()
	publish( FLAG, topicId, msg.c_str(), msg.length() ) 
}

// Callback de la methode register
MQTTSN_regack_handler( msg_regack ) {
	topicId = msg_regack->topic_id
	msg = getMessage()
	publish( FLAG, topicId, msg.c_str(), msg.length() )
}

// Callback de la methode subscribe_by_name
MQTTSN_suback_handler( msg_suback ) {
	if( msg_suback->return_code == ACCEPTED ){
		publish( FLAG, topicId, msg.c_str(), msg.length() )
	} else {
		subscribe_by_name( FLAG, TOPIC_SUB )
	}
}

// Callback de la methode publish
MQTTSN_puback_handler( msg_puback ) {
	if( msg_puback->return_code == ACCEPTED ) {
		disconnect( DISCONNECT_NOW )
	 } else if ( msg_puback->return_code == REJECTED) {
		connect( FLAG, KEEP_ALIVE, MODULE_NAME )
	}
}

// Callback de la methode disconnect
MQTTSN_disconnect_handler() {
}

// Callback de le methode publish
MQTTSN_publish_handler( msg_publish ) {
}
